/*
 Copyright (C) 2003 EBI, GRL

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.ensembl.driver.impl;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import org.ensembl.datamodel.ExternalDatabase;
import org.ensembl.datamodel.Persistent;
import org.ensembl.datamodel.impl.ExternalDatabaseImpl;
import org.ensembl.driver.AdaptorException;
import org.ensembl.driver.ExternalDatabaseAdaptor;

public class ExternalDatabaseAdaptorImpl extends BaseAdaptor implements
		ExternalDatabaseAdaptor {
	private static final Logger logger = Logger
			.getLogger(ExternalRefAdaptorImpl.class.getName());

	private boolean cachePreloaded = false;

  private String releaseColumnName;

	public ExternalDatabaseAdaptorImpl(CoreDriverImpl driver) {
		super(driver, 1000);
	}

	public String getType() throws org.ensembl.driver.AdaptorException {
		return TYPE;
	}

	/**
	 * @see org.ensembl.driver.Adaptor#clearCache()
	 */
	public void clearCache() {
		super.clearCache();
		cachePreloaded = false;
	}

	public List fetch() throws AdaptorException {
		if (!cachePreloaded) {
			// force all external databases to be loaded
			fetchByConstraint(null); 
			cachePreloaded = true;
		}
		return new ArrayList(cache.values());
	}

	public ExternalDatabase fetch(long externalDbId) throws AdaptorException {

		Persistent tmp = fetchFromCache(externalDbId);
		if (tmp != null)
			return (ExternalDatabase) tmp;

		return fetchByConstraint("external_db_id = " + externalDbId);
	}

	public ExternalDatabase fetch(String databaseName) throws AdaptorException {
		// TODO cache by name
		return fetchByConstraint("db_name = '" + databaseName + "'");
	}

  
  // enable backward compatibility with pre 38 schemas by supporting different
  // column names for the "release" column in the database.
  private String releaseColumnName() {
    if (releaseColumnName==null) 
      releaseColumnName = (getSchemaVersion().compareTo("38")>=0) ? "db_release" : "release";
    
    return releaseColumnName;
  }
  
	/**
	 * Returns the last external database that matches the constraint.
	 * 
	 * @param constraint
	 *            "where" condition(s), if null all external databases are
	 *            loaded into cache and the last external database loaded is
	 *            returned.
	 * @return last external database to match constraint or nullif no matches
	 *         found.
	 * @throws AdaptorException
	 */
	private ExternalDatabase fetchByConstraint(String constraint)
			throws AdaptorException {

		ExternalDatabase externalDatabase = null;
		ResultSet rs = null;
		Connection conn = null;
		PreparedStatement ps = null;

		try {
			// Retrieve row from database
			conn = getConnection();
			String sql = "SELECT              \n" + "   db_name,      \n"
					+ "   external_db_id,      \n" + "   "+releaseColumnName()+",      \n"
					+ "   status        \n" + "FROM                \n"
					+ "   external_db    \n"
					+ ((constraint != null) ? "WHERE \n" + constraint : "");

			rs = executeQuery(conn, sql);
			while (rs.next()) {
				externalDatabase = new ExternalDatabaseImpl(driver);
				externalDatabase.setInternalID(rs.getLong("external_db_id"));
				externalDatabase.setName(rs.getString("db_name"));
				externalDatabase.setStatus(rs.getString("status"));
				externalDatabase.setVersion(rs.getString(releaseColumnName));
				addToCache(externalDatabase);
			}
		} catch (SQLException e) {
			throw new AdaptorException(
					"Problem loading external databases with Constraint: "
							+ constraint, e);
		} finally {
			close(conn);
		}

		return externalDatabase;
	}

	/**
	 * @return internalID assigned to externalDatabase in database.
	 * @throws AdaptorException
	 *             if an adaptor error occurs
	 */
	public long store(ExternalDatabase externalDatabase)
			throws AdaptorException {
		// no need to supply xref_id value because it will be auto generated by
		// db.
		String sql = "INSERT INTO external_db (" + " db_name " // 1
				+ " ," +releaseColumnName() // 2
				+ " ,status " // 3
				+ " ) " + " VALUES (?, ?, ?) ";

		long internalID = 0;
		Connection conn = null;
		try {

			conn = getConnection();
			conn.setAutoCommit(false);

			PreparedStatement ps = conn.prepareStatement(sql);
			ps.setString(1, externalDatabase.getName());
			ps.setString(2, externalDatabase.getVersion());
			ps.setString(3, externalDatabase.getStatus());

			internalID = executeAutoInsert(ps, sql);

			conn.commit();
			externalDatabase.setDriver(driver);
			externalDatabase.setInternalID(internalID);
		} catch (Exception e) {
			rollback(conn);
			throw new AdaptorException("Failed to store externalDatabase: "
					+ externalDatabase, e);
		} finally {
			close(conn);
		}

		addToCache(externalDatabase);

		return internalID;
	}

	/**
	 * @param internalID
	 *            internalID of externalDatabase to be deleted from database.
	 * @throws AdaptorException
	 *             if an adaptor error occurs
	 */
	public void delete(long internalID) throws AdaptorException {

		if (internalID < 1)
			return;

		deleteFromCache(internalID);

		Connection conn = null;
		try {

			conn = getConnection();
			conn.setAutoCommit(false);

			delete(conn, internalID);

			conn.commit();
		} catch (Exception e) {
			rollback(conn);
			throw new AdaptorException("Failed to delete externalDatabase: "
					+ internalID, e);
		} finally {
			close(conn);
		}

	}

	/**
	 * @param externalDatabase
	 *            to be delete.
	 * @throws AdaptorException
	 *             if an adaptor error occurs
	 */
	public void delete(ExternalDatabase externalDatabase)
			throws AdaptorException {
		if (externalDatabase == null)
			return;
		delete(externalDatabase.getInternalID());
		externalDatabase.setInternalID(0);
	}

	/**
	 * Executes sql to delete row from external_db table.
	 */
	void delete(Connection conn, long internalID) throws AdaptorException {

		executeUpdate(conn, "delete from external_db where external_db_id = "
				+ internalID);

	}

}
