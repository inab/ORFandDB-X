/* Generated by Together */

package org.ensembl.driver.impl;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Logger;

import org.ensembl.datamodel.Feature;
import org.ensembl.datamodel.InvalidLocationException;
import org.ensembl.datamodel.Location;
import org.ensembl.datamodel.SimpleFeature;
import org.ensembl.datamodel.impl.SimpleFeatureImpl;
import org.ensembl.driver.AdaptorException;
import org.ensembl.driver.SimpleFeatureAdaptor;
import org.ensembl.util.NotImplementedYetException;

/**
 * Implementation of an adaptor to fetch simple features from the database,
 * using the new (seq_region based) API. Most of the work is done in
 * BaseFeatureAdaptorImpl.
 */

// TODO implement store/delete
public class SimpleFeatureAdaptorImpl extends BaseFeatureAdaptorImpl implements SimpleFeatureAdaptor {

	private static final Logger logger = Logger.getLogger(SimpleFeatureAdaptorImpl.class.getName());
	public final boolean CLIP = false;

	private String analysisIDCondition;

	public SimpleFeatureAdaptorImpl(CoreDriverImpl driver, String logicName, String type) {
		super(driver, logicName, type);
		analysisIDCondition = null;
	}

	public SimpleFeatureAdaptorImpl(CoreDriverImpl driver, String[] logicNames, String type) {
		super(driver, logicNames, type);
	}

	public SimpleFeatureAdaptorImpl(CoreDriverImpl driver) {
		super(driver, TYPE);
	}

	public long store(Feature feature) throws AdaptorException {
		Connection connection = null;
		long internalId = 0;
		try {
			connection = getConnection();
			connection.setAutoCommit(false);
			internalId = store(feature, connection);
			connection.commit();
		} catch (SQLException exception) {
			rollback(connection);
			throw new AdaptorException("Failed to store simpleFeature: " + feature, exception);
		} finally {
			close(connection);
		} //end try

		return internalId;
	}

	/**
	 * Assumes analysis object is set and that it has been stored in the
	 * database already.
	 * 
	 * @return internalID assigned to predictionTranscript in database.
	 * @throws AdaptorException
	 *             if an adaptor error occurs
	 */
	public long store(Feature feature, Connection connection) throws AdaptorException {

		/*
		 * String sql = " INSERT INTO simple_feature (" + " simple_feature_id, " + "
		 * contig_id, " + " contig_start, " + " contig_end, " + "
		 * contig_strand, " + " display_label, " + " analysis_id, " + " score " + " ) "+ "
		 * VALUES (?, ?, ?, ?, ?, ?, ?, ?) ";
		 * 
		 * long internalID = 0; PreparedStatement preparedStatement = null;
		 * LocationConverter locationConverter = null; CloneFragmentLocation
		 * contig = null;
		 * 
		 * try {
		 * 
		 * locationConverter = driver.getLocationConverter();
		 * 
		 * contig = (CloneFragmentLocation) locationConverter.convert(
		 * feature.getLocation(), CloneFragmentLocation.DEFAULT_MAP );
		 * 
		 * preparedStatement = connection.prepareStatement(sql);
		 * 
		 * //simple_feature_id preparedStatement.setInt( 1, 0 ); //forces mysql
		 * to auto-increment - internal id recovered after insertn.
		 * 
		 * //contig_id preparedStatement.setLong( 2,
		 * contig.getCloneFragmentInternalID() );
		 * 
		 * //contig_start preparedStatement.setInt( 3, contig.getStart() );
		 * 
		 * //contig_end preparedStatement.setInt( 4, contig.getEnd() );
		 * 
		 * 
		 * //contig_strand preparedStatement.setInt( 5, contig.getStrand() );
		 * 
		 * //display_label preparedStatement.setString( 6,
		 * feature.getDisplayName() );
		 * 
		 * //analysis_id preparedStatement.setLong( 7,
		 * feature.getAnalysis().getInternalID() );
		 * 
		 * //score preparedStatement.setInt( 8, 0 );
		 * 
		 * internalID = executeAutoInsert( preparedStatement, sql ); //returns
		 * the autogenerated internal id.
		 * 
		 * feature.setDriver( driver ); feature.setInternalID( internalID ); }
		 * catch (SQLException e) { throw new AdaptorException( "Failed to
		 * store predictionTranscript: "+ feature, e ); }//end try
		 * 
		 * return internalID;
		 */
		 throw new NotImplementedYetException("Not yet implemented in new API");

	} //end store


	// ---------------------------------------------------------------------

	protected String[] columns() {

		String[] cols =
			{
				"sf.simple_feature_id",
				"sf.seq_region_id",
				"sf.seq_region_start",
				"sf.seq_region_end",
				"sf.seq_region_strand",
				"sf.display_label",
				"sf.analysis_id",
				"sf.score" };

		return cols;

	} // columns

	// ---------------------------------------------------------------------

	protected String[][] tables() {

		String[][] tables = { { "simple_feature", "sf" }
		};

		return tables;

	}

	// ---------------------------------------------------------------------

	public Object createObject(ResultSet rs) throws AdaptorException {

		SimpleFeature sf = null;

		try {
		  if (rs.next()) {

				Location loc = new Location(
						rs.getLong("seq_region_id"),
						rs.getInt("seq_region_start"),
						rs.getInt("seq_region_end"),
						rs.getInt("seq_region_strand"));

				sf = new SimpleFeatureImpl(rs.getLong("seq_region_id"), loc);
				sf.setDisplayName(rs.getString("display_label"));
				sf.setScore(rs.getDouble("score"));
				sf.setAnalysisID(rs.getLong("analysis_id"));
				sf.setDriver(getDriver());
			}

		} catch (InvalidLocationException e) {
			throw new AdaptorException("Error when building Location", e);
		} catch (SQLException e) {
			throw new AdaptorException("SQL error when building object", e);
		}

		return sf;
	}

	// -----------------------------------------------------------------

	/**
	 * Fetch a SimpleFeature from the database.
	 * 
	 * @param internalID
	 *            The database ID of the SimpleFeature to fetch.
	 */
	public SimpleFeature fetch(long internalID) throws AdaptorException {

		// just use base class method with appropriate return type
		return (SimpleFeature)super.fetchByInternalID(internalID);

	}

	// -----------------------------------------------------------------
	/**
		 * @return A List of features matching the logicalName. In case there are
		 *         no features found, an Empty List is returned
		 */
	public List fetch(String logicalName) throws AdaptorException {

		return fetchByNonLocationConstraint(getAnalysisIDCondition(logicalName));

	}
	// -----------------------------------------------------------------

}
