#!/usr/bin/env python

# Program to merge stable_id_events generated by old and new ID Mapping programs.

# Craig Melsopp, 20/9/2005, LGPL

# Creates entries for stable_id_event table by merging data from *_stable_id tables from:
#   a) a source database
#   b) an old target database that contains stable ids mapped using the OLD id mapping program
#   c) a new target database that contains stable ids mapped using the NEW id mapping program
#
# Currently it writes CSV and SQL (insert statments) files to "output.dir" defined in CONFIG.INI.

# Usage:
#   merge_stable_ids.py CONFIG.INI 
#
# Example config file:
#   ensj-core/resources/data/merge_stable_id_events.ini

# TODO support automatic upload?

# TODO test on real data

# TODO Arne to clarify actions for cases: 001, 010, 011, 100. Spec unclear.

import os

# This isn't used in program but is written here for reference.
CREATE_STABLE_ID_EVENT_TABLE_SQL = """CREATE TABLE `stable_id_event` (
  `old_stable_id` varchar(128) default NULL,
  `old_version` smallint(6) default NULL,
  `new_stable_id` varchar(128) default NULL,
  `new_version` smallint(6) default NULL,
  `mapping_session_id` int(11) NOT NULL default '0',
  `type` enum('gene','transcript','translation') NOT NULL default 'gene',
  `mapping_type` enum('new_mapping','same','incorrect', 'new_similarity') NOT NULL default 'new_mapping',
  UNIQUE KEY `uni_idx` (`mapping_session_id`,`old_stable_id`,`old_version`,`new_stable_id`,`new_version`,`type`),
  KEY `new_idx` (`new_stable_id`),
  KEY `old_idx` (`old_stable_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1
"""



class StableID:
    """ An row from a *_stable_id table. Instances of this class represent the 'inputs' for the
    merger process. """
    def __init__(self, id, stable_id, version):
        self.id = id
        self.stable_id = stable_id
        self.version = version

    def to_csv(self):
        return "%s\t%s\t%s" % (self.id, self.stable_id, self.version)



class StableIDEvent:
    """ A Stable ID mapping event data type. This is the 'output' data type that the program
    produces. """
    def __init__(self, mapping_session_id, type, mapping_type, stable_id_a, stable_id_b, stable_id_c):
        self.type = type
        self.mapping_type = mapping_type
        self.set_old(stable_id_a)
        if stable_id_c:
            self.set_new(stable_id_c)
        elif stable_id_b:
            self.set_new(stable_id_b)
        else:
            self.set_new(None)
        self.mapping_session_id = mapping_session_id 


    def set_old(self, stable_id_entry):
        if stable_id_entry:
            self.old_stable_id = stable_id_entry.stable_id
            self.old_version = stable_id_entry.version
        else:
            self.old_stable_id = None
            self.old_version = None

    def set_new(self, stable_id_entry):
        if stable_id_entry:        
            self.new_stable_id = stable_id_entry.stable_id
            self.new_version = stable_id_entry.version
        else:
            self.new_stable_id = None
            self.new_version = None

    def __str__(self):
        return str(self.__dict__)

    def __repr__(self):
        return self.__str__()        

    def to_csv(self):
        return "%s\t%s\t\t%s\t%s\t%s\t%s\t%s" % (self.old_stable_id, self.old_version, self.new_stable_id, self.new_version, self.mapping_session_id, self.type, self.mapping_type)

    def to_sql_insert(self):
        def sql_quote(v):
            if v == None:
                return "NULL"
            else:
                return "\"%s\"" % (v)

        return "INSERT INTO stable_id_event (old_stable_id, old_version, new_stable_id, new_version, mapping_session_id, type, mapping_type) VALUES(%s,%s,%s,%s,%s,%s,%s);" % (sql_quote(self.old_stable_id), sql_quote(self.old_version), sql_quote(self.new_stable_id), sql_quote(self.new_version), self.mapping_session_id, sql_quote(self.type), sql_quote(self.mapping_type))



class DatabaseParameters:
    """ Database connection parameters. """
    def __init__(self, host,port,database,user, password):
        self.host=host
        self.port=int(port)
        self.database=database
        self.user=user
        self.password=password

    def __str__(self):
        return "%s:%s/%s" % (self.host,self.port,self.database)

    def __repr__(self):
        return self.__str__()

    def connection(self):
        import MySQLdb
        return MySQLdb.Connection(host=self.host,
                                      user=self.user,
                                      passwd=self.password,
                                      db=self.database,
                                      port=self.port,
                                      unix_socket="")




class DatabaseMergeTask:

    """ Defines a task to merge gene, transcript and translation stable ids
    from the source, new target and old target databases to produce the StableIDEvents.

    Caches *_stable_id tables in local files for optimisation purposes. 
    """
    
    def __init__(self,config, m):
        self.source_db = DatabaseParameters(config.get(m, "source.host"),
                                            config.get(m, "source.port"),
                                            config.get(m, "source.database"),
                                            config.get(m, "source.user"),
                                            config.get(m, "source.password"))
        self.newtarget_db = DatabaseParameters(config.get(m, "newtarget.host"),
                                               config.get(m, "newtarget.port"),
                                               config.get(m, "newtarget.database"),
                                               config.get(m, "newtarget.user"),
                                               config.get(m, "newtarget.password"))
        self.oldtarget_db = DatabaseParameters(config.get(m, "oldtarget.host"),
                                               config.get(m, "oldtarget.port"),
                                               config.get(m, "oldtarget.database"),
                                               config.get(m, "oldtarget.user"),
                                               config.get(m, "oldtarget.password"))
        self.output_dir = config.get(m,"output.dir")
        self.output_format = config.get(m,"output.format")
        if config.has_option(m,"verbose"):
            self.verbose = config.get(m,"verbose")
        else:
            self.verbose=None


    def run(self):
        self.init_output_dir()
        # could modify so that each is mapped and stored separately
        events = [] 
        self.merge("gene", events)
        self.merge("transcript", events)
        self.merge("translation", events)
        self.store(events)

        
    def init_output_dir(self):
        """ Create output dir if necessary. """
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)


    def merge(self, data_type, events):
        return merge(data_type,
                     self.load(self.source_db, data_type, self.output_dir),
                     self.load(self.oldtarget_db, data_type, self.output_dir),
                     self.load(self.newtarget_db, data_type, self.output_dir),
                     events)


    def store(self, events):
        """ Writes events to .txt file (CSV) and .sql (insert statements) file."""
        base_fname = "%s%s%s_%s_%s.stable_id_event" % (self.output_dir,
                                                              os.path.sep,
                                                              self.newtarget_db.database,
                                                              self.newtarget_db.host,
                                                              self.newtarget_db.port)
        fname2fn = {base_fname+".txt": "to_csv",
                    base_fname+".sql": "to_sql_insert"}
        for fname,fn in fname2fn.items():
            if self.verbose:
                print "WRITING",fname
            f = file(fname,'w')
            for event in events:
                print >> f, getattr(event,fn)()
            f.close()

        
    def load_stable_ids_from_cache(self, fname, data_type):
        """ Loads file into dictionary where dict[stable_id] = someStableID. """
        if self.verbose:
            print "LOADING", data_type, "from",fname
        return load_stable_ids_from_file(fname)
    

    def load_stable_ids_from_db(self, db, data_type, fname):
        if self.verbose:
            print "LOADING", data_type, "from", db
        sids = {}
        conn = db.connection()
        cursor = conn.cursor()
        cursor.execute("select %s_id, stable_id, version from %s_stable_id" % (data_type,data_type))
        count = 0
        while 1:
            row = cursor.fetchone()
            if row==None:
                break
            ## count+=1
            ## if count>100:
            ##    break
            sid = StableID(row[0], row[1], row[2])
            sids[sid.stable_id]=sid
        conn.close()

        if self.verbose:
            print "WRITING CACHE FILE",fname
        f = file(fname,'w')
        for sid in sids.values():
            print >>f, sid.to_csv()
        f.close()
        return sids
        

    def load(self, db, data_type, output_dir):
        fname = "%s%s%s_%s_%s_%s.cache" % (output_dir, os.path.sep, db.database,data_type,db.host,db.port)
        if os.path.exists(fname):
            sids = self.load_stable_ids_from_cache(fname, data_type)
        else:
            sids = self.load_stable_ids_from_db(db, data_type, fname)
        return sids

    
    def __str__(self):
        return "MergeTask"+str(self.__dict__)


    def __repr__(self):
        return self.__str__()        


class MergeApplication:

    def run(self):
        self.config = self.load_config()
        tasks = self.create_tasks()
        for task in tasks:
            task.run()        


    def create_tasks(self):
        tasks = []
        for m in self.config.sections():
            tasks.append(DatabaseMergeTask(self.config, m))
        return tasks


    def load_config(self):
        # default config file (used during development). Assumes running from ensj-core/scripts.
        config_file = os.curdir+os.path.sep+"../resources/data/merge_stable_id_events.ini"
        import sys
        if len(sys.argv)>1:
            config_file = sys.argv[1]

        import ConfigParser
        config_parser = ConfigParser.SafeConfigParser()
        config_parser.readfp(open(config_file))
        return config_parser


def create_stable_id_events(stable_ids, data_type, source_sids, old_target_sids, new_target_sids,events = []):
    """
    stable_ids  - collection of unique stable ids
    data_type - type of thing ids define, e.g. gene,transcript,translation
    source_sids - dictionary of stable_id->StableID entries from the source database
    old_target_sids - dictionary of stable_id->StableID entries from the old_target database
    new_sids - dictionary of stable_id->StableID entries from the new_target database
    events - output list for storing StableIDEvents

    return events
    """
    
    SPECIAL_CASE = 999
    ERROR  = "ERROR"
    NEW_MAPPING = "new_mapping"
    INCORRECT = "incorrect"
    SAME = "same"
    IGNORE = "IGNORE"
    
    # encode "mapping_type" as a string of binary flags where 0/1 represents abscence/prescence
    # of stable id in set a,b and c respectively
    rules = {int("000",2):ERROR,
             int("001",2):NEW_MAPPING, # NEW_MAPPING OR IGNORE, spec unclear
             int("010",2):INCORRECT, # INCORRECT OR IGNORE, spec unclear
             int("011",2):SAME, # SAME OR IGNORE, spec unclear
             int("100",2):SAME, # SAME OR IGNORE, spec unclear
             int("101",2):NEW_MAPPING,
             int("110",2):INCORRECT,
             int("111",2):SPECIAL_CASE,
             }
    for stable_id in stable_ids:

        index = 0

        try:
            stable_id_source = source_sids[stable_id]
            index= index | 4
        except:
            stable_id_source = None

        try:
            stable_id_old = old_target_sids[stable_id]
            index = index | 2
        except:
            stable_id_old = None

        try:
            stable_id_new = new_target_sids[stable_id]
            index = index | 1
        except:
            stable_id_new = None

        mapping_type = rules[index]
        if mapping_type == SPECIAL_CASE:
            if stable_id_old.id==stable_id_new.id:
                events.append(StableIDEvent(-999, data_type, SAME, stable_id_source, stable_id_old, stable_id_new))
            else:
                events.append(StableIDEvent(-999, data_type, NEW_MAPPING, stable_id_source, stable_id_old, stable_id_new))
                # Do we need this incorrect entry?
                events.append(StableIDEvent(-999, data_type, INCORRECT, stable_id_source, stable_id_old, None))
        elif mapping_type == IGNORE:
            pass
        else:
            events.append(StableIDEvent(-999, data_type, mapping_type, stable_id_source, stable_id_old, stable_id_new))

    return events



def load_stable_ids_from_file(fname):
    sids = {}
    f = file(fname)
    for line in f.xreadlines():
        line = line.strip()
        if len(line)==0:
            continue
        id, stable_id, version = line.split()[0:3]
        sids[stable_id] = StableID(id, stable_id, version)
    f.close()
    return sids


def unique_keys(dictionaries):
    import sets
    keys = sets.Set()
    for m in dictionaries:
        for stable_id in m.keys():
            keys.add(stable_id)
    return keys


def merge(data_type, source_sids, old_target_sids, new_target_sids, events = []):

    stable_ids = unique_keys([source_sids,
                              old_target_sids,
                              new_target_sids])

    return create_stable_id_events(stable_ids,
                                   data_type,
                                   source_sids,
                                   old_target_sids,
                                   new_target_sids,
                                   events)


def test():
    events = merge("gene",
                   load_stable_ids_from_file("/tmp/gene_stable_id_original.txt"),
                   load_stable_ids_from_file("/tmp/gene_stable_id_old_mappings.txt"),
                   load_stable_ids_from_file("/tmp/gene_stable_id_new_mappings.txt"))
    for event in events:
        print event.to_csv()

 




if __name__=="__main__":
    #test()
    MergeApplication().run()
        


        
