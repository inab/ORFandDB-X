#!/usr/bin/perl -w

use strict;

sub ISO8601date($);
sub XMLize($);
sub referenceTagger($);
sub toRef($$);
sub toECRef($);
sub toSNPRef($$);
sub printAlias($\@);
sub printMutation($$$);
sub printText($\@);

# Mutation handling
sub processMutation($\@$);

if(scalar(@ARGV)!=2) {
	die "This program takes two parameters: the OMIM directory and the output XML file\n";
}

local(*MAP);

# Reading various codes
my($defaultType)='none';
my($removedType)='removed';
my($unknownType)='unknown';
my(%RECORDTYPE)=(
	'#' => 'number',
	'+' => 'plus',
	'*' => 'asterisk',
	'%' => 'percent',
	'^' => $removedType,
);

my(@STATUSCODE)=();
my(@METHODCODE)=();
my($line);

open(MAP,'<'.$ARGV[0].'/genemap.key') || die "ERROR: Unable to open $ARGV[0]/genemap.key for processing\n";

my($codes)=undef;
my($codekey)=undef;
my($codeval)=undef;
while($line=<MAP>) {
	if(defined($codes)) {
		chomp($line);
		if($line =~ /^-+/) {
			# Storing all what is storable
			if(defined($codes)) {
				if(defined($codekey)) {
					push(@{$codes},[$codekey,$codeval]);
					$codekey=undef;
					$codeval=undef;
				}
				$codes=undef;
			}
		} elsif($line =~ /^([^ ]+) = /) {
			push(@{$codes},[$codekey,$codeval])  if(defined($codekey));
			$codekey=$1;
			$codeval=substr($line,index($line,' = ')+3);
		} elsif(defined($codeval)) {
			$line =~ s/^[ \t]+//;
			$codeval .=  ' '. $line;
		}
	} elsif($line =~ /^Status codes/) {
		$codes=\@STATUSCODE;
	} elsif($line =~ /^Method codes/) {
		$codes=\@METHODCODE;
	}
}
# Storing all what is storable
if(defined($codes)) {
	if(defined($codekey)) {
		push(@{$codes},[$codekey,$codeval]);
		$codekey=undef;
		$codeval=undef;
	}
	$codes=undef;
}

close(MAP);

# Reading gene map

open(MAP,'<'.$ARGV[0].'/genemap') || die "ERROR: Unable to open $ARGV[0]/genemap for processing\n";

my(%map)=();
while($line=<MAP>) {
	last unless(index($line,'|'));
	
	chomp($line);
	my(@entry)=split(/\|/,$line);
	# location, gene symbols, entered date, status code, method codes,
	my(@gsymbols)=split(/, /,$entry[5]);
	my(@mcodes)=split(/, /,$entry[10]);
	#print $line,"\n"  if($entry[9] eq '');
	push(@{$map{$entry[9]}},[
		$entry[4],
		\@gsymbols,
		($entry[3]+1900+(($entry[3]<50)?100:0)).'-'.$entry[1].'-'.$entry[2],
		$entry[6],
		\@mcodes,
		$entry[16],
	]);
}

close(MAP);

# Reading morbid map (disabled)
#open(MAP,'<'.$ARGV[0].'/morbidmap') || die "ERROR: Unable to open $ARGV[0]/morbidmap for processing\n";
#
#while($line=<MAP>) {
#	last unless(index($line,'|'));
#	
#	chomp($line);
#	my(@entry)=split(/\|/,$line);
#	unless(exists($map{$entry[2]})) {
#		$map{$entry[2]}=[];
#		print STDERR $map{$entry[2]},"\n";
#	}
#	push(@{$map{$entry[2]}},"joder");
#}
#
#close(MAP);

local(*OMIM);

open(OMIM,"gunzip -c '$ARGV[0]/omim.txt.Z' |") || die "ERROR: Unable to open $ARGV[0] for processing\n";

local(*OUTPUT);

if(open(OUTPUT,'>'.$ARGV[1])) {
	print OUTPUT<<EOF;
<?xml version='1.0' encoding='ISO-8859-1'?>


<!--
	This XML document was generated by OMIM2ODB.pl script
	which was created by José María Fernández González
	jmfernandez\@cnio.es CNIO (C) 2007
	
	The contents of this file were generated from
	OMIM database, and they are subjected to the
	next copyright:
	
	Copyright (c) 1966-2007 Johns Hopkins University
	
	The original contents came from next files:
	-	genemap.key
	-	genemap
	-	omim.txt.Z
-->
<OMIM xmlns='http://www.pdg.cnb.uam.es/jmfernandez/ORFandDB/4.0/OMIM' xmlns:odb='http://www.pdg.cnb.uam.es/jmfernandez/ORFandDB/4.0'>
EOF

	# Printing the codes information
	print OUTPUT "\t<codes>\n";

	foreach my $keyval (@STATUSCODE) {
		print OUTPUT "\t\t<statusCode key='$keyval->[0]'>$keyval->[1]</statusCode>\n";
	}

	foreach my $keyval (@METHODCODE) {
		print OUTPUT "\t\t<methodCode key='$keyval->[0]'>$keyval->[1]</methodCode>\n";
	}

	print OUTPUT "\t</codes>\n";
	
	my($currentField)=undef;
	my($mimNumber)=undef;
	my($recordType)=undef;
	my($title)=undef;
	my($mainGeneSymbol)=undef;
	my(@movedMim)=();
	my(@alias)=();
	my($isAlias)=1;
	my(@included)=();
	my($seeAlso)='';
	my($bibtmp)=undef;
	my(@bibref)=();
	my(@clinicalSynopsis)=();
	my($clitext)=undef;
	my($clitmp)=undef;
	my(@created)=();
	my(@edited)=();
	my(@attribution)=();
	my(@section)=();
	my($sectmp)=undef;
	my(@allelicVariant)=();
	my($alltmp)=undef;
	my($allhd)=undef;
	my($gotTit)=undef;
	while($line=<OMIM>) {
		chomp($line);
		if($line eq "*RECORD*" || $line eq "*THEEND*") {
			# Is this the first record?
			if(defined($mimNumber)) {
				print OUTPUT "\t<record mimNumber='$mimNumber' type='$recordType' title='",XMLize($title),"'>\n";
				if($recordType ne $removedType) {
					# Alias
					printAlias(\*OUTPUT,@alias);
					
					# Locus
					foreach my $feature (@{$map{$mimNumber}}) {
						print OUTPUT "\t\t<locus id='$feature->[0]' status='$feature->[3]' eDate='$feature->[2]'>\n";
						foreach my $gsymbol (@{$feature->[1]}) {
							print OUTPUT "\t\t\t<geneSymbol>$gsymbol</geneSymbol>\n";
						}
						foreach my $method (@{$feature->[4]}) {
							print OUTPUT "\t\t\t<mappingMethod>$method</mappingMethod>\n";
						}
						print OUTPUT "\t\t</locus>\n";
					}
					
					# included
					foreach my $incl (@included) {
						$incl =~ s/^ +//;
						next if(length($incl)==0);
						print OUTPUT "\t\t<included>",XMLize($incl),"</included>\n";
					}
				
					# seeAlso
					foreach my $seea (split(/; /,$seeAlso)) {
						next if(length($seea)==0);
						print OUTPUT "\t\t<seeAlso>",XMLize($seea),"</seeAlso>\n";
					}
				} else {
					foreach my $mMim (@movedMim) {
						print OUTPUT "\t\t<movedTo mimNumber='$mMim' />\n";
					}
				}
					
				# text
				printText(\*OUTPUT,@section);
					
				# allelicVariant
				foreach my $alle (@allelicVariant) {
					my($alleT)=undef;
					my($mimA)=undef;
					my($alleA)=undef;
					if(defined($alle->[1])) {
						if($alle->[1] =~ /^MOVED TO ([0-9]+)\.([0-9]+)/) {
							$alleT='removed';
							$mimA=$1;
							$alleA=$2;
						} elsif($alle->[1] eq 'REMOVED FROM DATABASE') {
							$alleT='removed';
						}
					}
					print OUTPUT	"\t\t<allelicVariant allelicID='",$alle->[0],
							"' name='",(defined($alle->[1])?XMLize($alle->[1]):'');
					print OUTPUT	"' type='",$alleT  if(defined($alleT));
					print OUTPUT	"'>\n";
					unless(defined($alleT)) {
						printAlias(\*OUTPUT,@{$alle->[3]});
						printMutation(\*OUTPUT,$mainGeneSymbol,$alle->[2]);
						printText(\*OUTPUT,@{$alle->[4]});
					} elsif(defined($mimA)) {
						print OUTPUT "\t\t\t<movedTo mimNumber='$mimA' allelicID='$alleA' />\n";
					}
					print OUTPUT "\t\t</allelicVariant>\n";
				}

				# bibref
				foreach my $bibind (0..$#bibref) {
					next unless(defined($bibref[$bibind]));

					print OUTPUT "\t\t<bibref num='$bibind'>",XMLize($bibref[$bibind]),"</bibref>\n";
				}
				
				# clinicalSynopsis
				if(scalar(@clinicalSynopsis)>0) {
					print OUTPUT "\t\t<clinicalSynopsis>\n";
					foreach my $syno (@clinicalSynopsis) {
						print OUTPUT "\t\t\t<key name='$syno->[0]'>\n";
						foreach my $term (@{$syno->[1]}) {
							next if($term eq '');
							print OUTPUT "\t\t\t\t<term>",referenceTagger($term),"</term>\n";
						}
						print OUTPUT "\t\t\t</key>\n";
					}
					print OUTPUT "\t\t</clinicalSynopsis>\n";
				}

				# entryHistory
				print OUTPUT "\t\t<entryHistory>\n";
				if(scalar(@created)>0) {
					print OUTPUT "\t\t\t<created date='$created[1]'>$created[0]</created>\n";
				}
				foreach my $attr (@attribution) {
					print OUTPUT "\t\t\t<atribution date='$attr->[1]'>$attr->[0]</atribution>\n";
				}
				foreach my $edit (@edited) {
					print OUTPUT "\t\t\t<edited date='$edit->[1]'>$edit->[0]</edited>\n";
				}
				print OUTPUT "\t\t</entryHistory>\n";
				print OUTPUT "\t</record>\n";
				
				# And now, cleanup
				$currentField=undef;
				$mimNumber=undef;
				$recordType=undef;
				$title=undef;
				$mainGeneSymbol=undef;
				@movedMim=();
				$isAlias=1;
				@alias=();
				@included=();
				$seeAlso='';
				@bibref=();
				$bibtmp=undef;
				@clinicalSynopsis=();
				$clitmp=undef;
				$clitext=undef;
				@created=();
				@edited=();
				@attribution=();
				@section=();
				$sectmp=undef;
				@allelicVariant=();
				$alltmp=undef;
				$allhd=undef;
				$gotTit=undef;
			}


		} elsif($line =~ /^\*FIELD\* ([A-Z][A-Z])/) {
			# Processing the different fields
			$currentField=$1;
			$sectmp=undef;
			$isAlias=undef;
		} elsif($currentField eq 'NO') {
			$mimNumber=$line;
		} elsif($currentField eq 'TI') {
			if(defined($title)) {
				unless(defined($gotTit)) {
					my($semidx)=undef;
					if(($semidx=index($line,';;'))!=-1) {
						$gotTit=1;
						$isAlias=($semidx==0)?1:undef;
					} elsif(index($line,'INCLUDED')!=-1) {
						$gotTit=1;
						$isAlias=undef;
					} else {
						$title .= ' '.$line;
					}
				}
				if(defined($gotTit)) {
					if(defined($isAlias)) {
						push(@alias,split(/;/,$line));
						# Have we finished with aliases?
						$isAlias=undef  unless($line =~ /;;$/);
					} else {
						push(@included,split(/;/,$line));
					}
				}
			} else {
				# Title and type processing
				my($ftype);
				($ftype,$title)=split(/ /,$line,2);
				
				$ftype=substr($ftype,0,1);
				if(exists($RECORDTYPE{$ftype})) {
					$recordType=$RECORDTYPE{$ftype};
				} elsif($ftype =~ /[0-9]/) {
					$recordType=$defaultType;
				} else {
					$recordType=$unknownType;
				}
				
				if($recordType eq $removedType) {
					foreach my $reToken (split(/[ ,]+/,$title)) {
						push(@movedMim,$reToken)  if($reToken =~ /^[0-9]+$/);
					}
				} elsif($title =~ /; *([^;]+)$/) {
					$mainGeneSymbol=$1;
				}
			}
		} elsif($currentField eq 'SA') {
			if(length($seeAlso)==0) {
				$seeAlso = $line;
			} else {
				$seeAlso .= ' ' . $line;
			}
		} elsif($currentField eq 'RF') {
			if(defined($bibtmp)) {
				if(length($line)>0) {
					$$bibtmp .= ' ' . $line;
				} else {
					$bibtmp=undef;
				}
			} elsif($line =~ /^([1-9][0-9]*)\. (.+)/) {
				$bibref[$1]=$2;
				$bibtmp = \$bibref[$1];
			}
		} elsif($currentField eq 'TX') {
			if(length($line)==0) {
				if(!defined($sectmp) || defined($sectmp->[2])) {
					my(@secdesc)=(0,undef,undef);
					$sectmp=\@secdesc;
					push(@section,$sectmp);
				}
			} else {
				if(!defined($sectmp) || ($sectmp->[0]>0 && !defined($sectmp->[2]) && ((uc($line) eq $line) || ($line =~ /^- /)))) {
					my(@secdesc)=(0,undef,undef);
					$sectmp=\@secdesc;
					push(@section,$sectmp);
				}
				
				# Do we have text?
				if(defined($sectmp->[2])) {
					$sectmp->[2] .= "\n".$line;
				} else {
					if(uc($line) eq $line) {
						$sectmp->[0]=1;
						$sectmp->[1]=$line;
					} elsif($line =~ /^- /) {
						$sectmp->[0]=2;
						$sectmp->[1]=substr($line,2);
					} else {
						$sectmp->[2]=$line;
					}
				}
			}
		} elsif($currentField eq 'AV') {
			if($line =~ /^\.([0-9]+)/) {
				# TODO: synchronize this code with
				# the previous one
				if(defined($allhd)) {
					if(defined($isAlias)) {
						$alltmp->[1]=''  unless(defined($alltmp->[1]));
						$isAlias=undef;
					}

					if(!defined($alltmp->[2])) {
						if(scalar(@{$alltmp->[3]})>0) {
							$alltmp->[2]=join(';',@{$alltmp->[3]});
							@{$alltmp->[3]}=();
						} else {
							$alltmp->[2]='';
						}
					}
					$allhd=undef;
				}

				# New allelic variant
				my(@atmp)=();
				my(@btmp)=();
				my(@newalle)=($1,undef,undef,\@atmp,\@btmp);
				$alltmp=\@newalle;
				push(@allelicVariant,$alltmp);
				$sectmp=undef;
				$isAlias=0;
				$allhd=1;
			} elsif(defined($alltmp)) {
				if(defined($allhd)) {
					if(length($line)>0) {
						if(defined($isAlias)) {
							if($isAlias eq '0') {
								unless(defined($alltmp->[1])) {
									$alltmp->[1] = $line;
								} else {
									$alltmp->[1] .= ' '.$line;
								}
								unless($line =~ /, *$/) {
									$isAlias=1;
								}
							} else {
								push(@{$alltmp->[3]},split(/;/,$line));
								# Have we finished with aliases?
								$isAlias=undef  unless($line =~ /;;$/ || $line =~ /, *$/);
							}
						} else {
							push(@{$alltmp->[3]},split(/;/,$alltmp->[2]))  if(defined($alltmp->[2]));
							$alltmp->[2] = $line;
						}
					} else {
						if(defined($isAlias)) {
							$alltmp->[1]=''  unless(defined($alltmp->[1]));
							$isAlias=undef;
						}
						
						if(!defined($alltmp->[2])) {
							if(scalar(@{$alltmp->[3]})>0) {
								$alltmp->[2]=join(';',@{$alltmp->[3]});
								@{$alltmp->[3]}=();
							} else {
								$alltmp->[2]='';
							}
						}
						$allhd=undef;
					}
				} elsif(length($line)==0) {
					if(!defined($sectmp) || defined($sectmp->[2])) {
						my(@secdesc)=(0,undef,undef);
						$sectmp=\@secdesc;
						push(@{$alltmp->[4]},$sectmp);
					}
				} else {
					if(!defined($sectmp) || ($sectmp->[0]>0 && !defined($sectmp->[2]) && ((uc($line) eq $line) || ($line =~ /^- /)))) {
						my(@secdesc)=(0,undef,undef);
						$sectmp=\@secdesc;
						push(@{$alltmp->[4]},$sectmp);
					}

					# Do we have text?
					if(defined($sectmp->[2])) {
						$sectmp->[2] .= "\n".$line;
					} else {
						if(uc($line) eq $line) {
							$sectmp->[0]=1;
							$sectmp->[1]=$line;
						} elsif($line =~ /^- /) {
							$sectmp->[0]=2;
							$sectmp->[1]=substr($line,2);
						} else {
							$sectmp->[2]=$line;
						}
					}
				}
			}
		} elsif($currentField eq 'CS') {
			if(defined($clitext)) {
				$line =~ s/^ +//;
				
				if(length($line)>0) {
					my($semicolon)=index($line,';');
					if($semicolon!=-1) {
						if(defined($clitmp)) {
							$$clitmp .= ' '  if(length($$clitmp)>0);
							$$clitmp .= substr($line,0,$semicolon);
						}
						push(@{$clitext},substr($line,$semicolon+1));
						$clitmp=\$clitext->[scalar(@{$clitext})-1];
					} elsif(defined($clitmp)) {
						$$clitmp .= ' '  if(length($$clitmp)>0); 
						$$clitmp .= $line;
					}
				} else {
					$clitext=undef;
					$clitmp=undef;
				}
			} elsif($line =~ /^([^: ]+):/) {
				my(@newarr)=('');
				$clitext=\@newarr;
				$clitmp=\$newarr[0];
				push(@clinicalSynopsis,[$1,$clitext]);
			}
		} elsif($currentField eq 'CD') {
			next  if(length($line)==0);
			my($CD)=rindex($line,' ');
			if($CD!=-1 && length($line)>($CD+1)) {
				my($name)=substr($line,0,$CD);
				$name =~ s/[: -]+$//;
				@created=($name,ISO8601date(substr($line,$CD+1)));
			} else {
				print STDERR "ProblemCD $mimNumber: $line\n";
			}
		} elsif($currentField eq 'CN') {
			next  if(length($line)==0);
			my($CN)=rindex($line,' ');
			if($CN!=-1 && length($line)>($CN+1)) {
				my($name)=substr($line,0,$CN);
				$name =~ s/[: -]+$//;
				push(@attribution,[$name,ISO8601date(substr($line,$CN+1))]);
			} else {
				print STDERR "ProblemCN $mimNumber: $line\n";
			}
		} elsif($currentField eq 'ED') {
			next  if(length($line)==0);
			my($ED)=rindex($line,' ');
			if($ED!=-1 && length($line)>($ED+1)) {
				my($name)=substr($line,0,$ED);
				$name =~ s/[: -]+$//;
				push(@edited,[$name,ISO8601date(substr($line,$ED+1))]);
			} else {
				print STDERR "ProblemED $mimNumber: $line\n";
			}
		}
	}
	
	print OUTPUT "</OMIM>\n";
	close(OUTPUT);
} else {
	warn "ERROR: Unable to open $ARGV[1] for writing\n";
}
close(OMIM);

exit(0);

# Now the methods

# Translates an American date to an ISO8601 one
sub ISO8601date($) {
	my(@splitdate)=split(/\//,$_[0],3);
	
	$splitdate[0]= '0'.$splitdate[0]  if(length($splitdate[0])==1);
	$splitdate[1]= '0'.$splitdate[1]  if(length($splitdate[1])==1);
	return $splitdate[2].'-'.$splitdate[0].'-'.$splitdate[1];
}

# This function creates/adds the needed tags
# to the input text
sub referenceTagger($) {
	my($totag)=XMLize($_[0]);
	
	$totag =~ s/(?<=[ \n])(rs[0-9]+[A-Z]*)/&toSNPRef($1)/sge;
	$totag =~ s/EC[ \n]((?:[0-9]+\.){3}[0-9]+)/&toECRef($1)/sge;
	# This has been a hard pattern, because there are some interferences with SNP marking up
	$totag =~ s/(?<!['>s0-9])([0-9]{6})(?:\.([0-9]{4}))?(?![0-9])/&toRef($1,$2)/sge;
#	$totag =~ s/(?:([^ (>]+)(;[ \n]+))?([0-9]{6})(?:\.([0-9]{4}))?/&toRef($1,$2,$3,$4)/sge;
#	$totag =~ s/(?:[^ (]+;[ \n]+)?[0-9]{6}(?:\.[0-9]{4})?/&toRef($1,$2,$3,$4)/sge;
	
	return $totag;
}

sub toRef($$) {
	return "<odb:link id='$_[0]' namespace='MIM'>".(defined($_[1])?"<odb:attr name='allelicID'>$_[1]</odb:attr>":'').'<odb:text>'.$_[0].(defined($_[1])?".$_[1]":'').'</odb:text></odb:link>';
#	return "<ref mimNumber='$_[0]'".(defined($_[1])?" allelicID='$_[1]'":'').">".$_[0].(defined($_[1])?".$_[1]":'').'</ref>';
#	return "<ref mimNumber='$_[2]'".(defined($_[3])?" allelicID='$_[3]'":'').">".(defined($_[0])?($_[0].$_[1]):'').$_[2].(defined($_[3])?".$_[3]":'').'</ref>';
#	$_[0] =~ /^(?:([^ (]+)(;[ \n]+))?([0-9]{6})(?:\.([0-9]{4}))?$/;
#	return "<ref mimNumber='$3'".(defined($4)?" allelicID='$4'":'').">".(defined($1)?($1.$2):'').$3.(defined($4)?".$4":'').'</ref>';
}

sub toECRef($) {
	return "<odb:link id='$_[0]' namespace='ENZYME'><odb:text>EC $_[0]</odb:text></odb:link>";
}

sub toSNPRef($$) {
	return "<odb:link id='$_[0]' namespace='dbSNP'><odb:text>$_[0]</odb:text></odb:link>";
}

# This function substitutes offending XML
# symbols by friendly equivalent ones
sub XMLize($) {
	my($text)=@_;
	$text =~ s/&/&amp;/g;
	$text =~ s/</&lt;/g;
	$text =~ s/'/&apos;/g;
	
	return $text;
}	

sub printAlias($\@) {
	my($OUTPUT,$p_alias)=@_;
	
	foreach my $ali (@{$p_alias}) {
		$ali =~ s/^ +//;
		next if(length($ali)==0);
		print $OUTPUT "\t\t<alias>$ali</alias>\n";
	}
}

sub printSubstitution($$) {
	my($OUTPUT)=$_[0];
	my($nttype,$coords,$fromplace,$toplace,$oldnt,$nt,$on,$extension)=@{$_[1]};
	
	print $OUTPUT "<substitution",
		(defined($nttype)?" resType='$nttype'":''),
		(defined($coords)?" coords='$coords'":''),
		(defined($fromplace)?" start='$fromplace'":''),
		(defined($toplace)?" stop='$toplace'":''),
		(defined($oldnt)?" oldRes='$oldnt'":''),
		(defined($nt)?" newRes='$nt'":''),
		(defined($on)?" on='$on'":''),
		(defined($extension)?" addedExt='$extension'":''),
		" />";
}

sub processSubstitution($$) {
	my($oldN,$newN,$place)=(undef,undef,undef);
	my($on,$extension)=(undef,undef);
	my($nttype,$coords)=(undef,undef);
	my($lmlength)=undef;
	my($place2)=undef;
	
	if($_[1] =~ /^([ATCG]+)[-\/]([ATCG]+)(?:, (?:NT)?([-+]?[0-9]+))?/) {
		$oldN=$1;
		$newN=$2;
		$nttype='NT';
		if(defined($3)) {
			$place=$3;
			$coords='NT';
		}
		$lmlength=length($&);
	} elsif($_[1] =~ /^([-+]?[0-9]+)[, ]*([ATCG]+)[-\/]([ATCG]+)/) {
		$place=$1;
		$oldN=$2;
		$newN=$3;
		$nttype=$coords='NT';
		$lmlength=length($&);
	} elsif($_[1] =~ /^(-?[0-9]*)(?:\+(-?[0-9]+))?[, ]*([ATCG]+)[-\/]([ATCG]+)/) {
		$place=$1 if(length($1)>0);
		$extension=$2  if(defined($2));
		$oldN=$3;
		$newN=$4;
		$nttype=$coords='NT';
		$lmlength=length($&);
	} elsif($_[1] =~ /^([ATCG-]+)(-?[0-9]+)([ATCG]+)/) {
		$oldN=$1;
		$place=$2;
		$newN=$3;
		$nttype=$coords='NT';
		$lmlength=length($&);
	} elsif($_[1] =~ /^NT(-?[0-9]+)/) {
		$place=$1;
		$coords='NT';
		$lmlength=length($&);
	#} elsif($_[1] =~ /^(-?[0-9]*)([ATCG]+)-([ATCG]+)/) {
	#	$place=$1 if(length($1)>0);
	#	$oldN=$2;
	#	$newN=$3;
	#	$nttype=$coords='NT';
	#	$lmlength=length($&);
	} elsif($_[1] =~ /^((?:INS)|(?:DEL)) EXON ([0-9]+)/) {
		$place=$2;
		$nttype=$coords='EX';
		if($1 eq 'INS') {
			$newN=$1;
		} else {
			$oldN=$1;
		}
		$lmlength=length($&);
	} elsif($_[1] =~ /^IVS((?:AS)|(?:DS))([0-9]+)/) {
		$newN=$1;
		$nttype='IVS';
		$place=$2;
		$coords='IVS';
		$lmlength=length($&);
	} elsif($_[1] =~ /^IVS([0-9]*)(?:-([0-9]+))?[- ]?((?:AS)|(?:DS))?/) {
		if(length($1)>0) {
			$place=$1;
			$place2=$2  if(defined($2));
			$coords='IVS';
		}
		if(defined($3)) {
			$newN=$3;
			$nttype='IVS';
		}
		$lmlength=length($&);
	} elsif($_[1] =~ /^INTRON ([0-9]+)/) {
		$place=$1;
		$coords='IVS';
		$lmlength=length($&);
	} elsif($_[1] =~ /^EX([0-9]+)(?:-([0-9]+))? ?((?:INS)|(?:DEL))?/) {
		$place=$1;
		$coords='EX';
		$place2=$2  if(defined($2));
		if(defined($3)) {
			if($3 eq 'INS') {
				$newN=$3;
			} else {
				$oldN=$3;
			}
		}
		$lmlength=length($&);
	} elsif($_[1] =~ /^EXON ([0-9]+)(?:-([0-9]+))? ?((?:INS)|(?:DEL))?/) {
		$place=$1;
		$coords='EX';
		$place2=$2  if(defined($2));
		if(defined($3)) {
			if($3 eq 'INS') {
				$newN=$3;
			} else {
				$oldN=$3;
			}
		}
		$lmlength=length($&);
	} elsif($_[1] =~ /^([A-Z]{3})((?:-?[0-9]+)|I)([A-Z]{3})(?: ON ([A-Z0-9]+))?/) {
		$oldN=$1;
		$place=$2;
		$newN=$3;
		$on=$4  if(defined($4));
		$nttype=$coords='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^([A-Z]{3}(?:-[A-Z]{3})*) ((?:INS)|(?:DEL))(?:, CODONS? ([0-9]+)\+?(?:(?:[-\/,]|(?: OR ))([0-9]+))?)?/) {
		if($2 eq 'DEL') {
			$oldN=$1;
		} else {
			$newN=$1;
		}
		$nttype='AA';
		$place=$3  if(defined($3) && length($3)>0);
		$place2=$4  if(defined($4) && length($4)>0);
		$coords='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^([A-Z]{3})[-?]([A-Z]{3})/) {
		$oldN=$1;
		$newN=$2;
		$nttype='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^TER-([A-Z]{3})/) {
		$oldN='TER';
		$newN=$1;
		$nttype='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^TER([0-9]+)/) {
		$newN='TER';
		$place=$1;
		$nttype=$coords='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^([A-Z]{3})(-?[0-9]+)/) {
		$oldN=$1;
		$place=$2;
		$nttype=$coords='AA';
		$lmlength=length($&);
	} elsif($_[1] =~ /^(-?[0-9]+)([A-Z]+)/) {
		$oldN=$2;
		$place=$1;
		$nttype=$coords='AA';
		$lmlength=length($&);
	} else {
		unkMutation($_[0],$_[1]);
		return undef;
	}
	
	my($OUTPUT)=$_[0];
	
	printSubstitution($_[0],[$nttype,$coords,$place,$place2,$oldN,$newN,$on,$extension]);
	
	my($postplace)=substr($_[1],$lmlength);
	$postplace =~ s/^[, \/;]+//;
	
	return $postplace;
}

sub dbSNPVariant($$) {
	my($OUTPUT)=$_[0];
	
	# Pulling RS initials
	my($link)=substr($_[1],2);
	
	print $OUTPUT "<odb:link namespace='dbSNP' id='rs".$link."' />";
	
	return undef;
}

sub unspecificMutation($$) {
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<unspecificMutation>",$_[1],"</unspecificMutation>";
	
	return undef;
}

sub unspecificDeletion($$) {
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<unspecificDeletion><geneSymbol>",$_[1],"</geneSymbol></unspecificDeletion>";
}

sub promoterDeletion($) {
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<promoterDeletion />";
}

sub geneFusion($$) {
	my($OUTPUT,$geneList)=@_;
	$geneList =~ s#/#</geneSymbol><geneSymbol>#g;
	print $OUTPUT "<fusion><geneSymbol>",$geneList,"</geneSymbol></fusion>";
}

sub unkMutation($$) {
	my($OUTPUT)=$_[0];
	print $OUTPUT "<unkMutation>$_[1]</unkMutation>";
}

sub frameShift($$) {
	my($lmlength)=undef;
	
	if(index($_[1],'FS')==0) {
		$lmlength=2;
	} else {
		unkMutation($_[0],$_[1]);
		return undef;
	}
	
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<frameShift />";
	
	my($postplace)=substr($_[1],$lmlength);
	$postplace =~ s/^[, .]+//;
	
	return $postplace;
}

sub frameShiftGenTer($$) {
	my($place)=undef;
	
	my($lmlength)=undef;
	if($_[1] =~ /^FS(-?[0-9]+)TER/) {
		$place=$1;
		$lmlength=length($&);
	} elsif($_[1] =~ /^FS, TER/) {
		$lmlength=length($&);
	} else {
		unkMutation($_[0],$_[1]);
		return undef;
	}
	
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<frameShift",
		(defined($place)?" place='$place'":''),
		" ter='true' />";
	
	my($postplace)=substr($_[1],$lmlength);
	$postplace =~ s/^[, .]+//;
	
	return $postplace;
}

sub processInsDelDup($$) {
	my(@numunittag)=();
	my($fromplace,$toplace)=(undef,undef);
	my($coords)=undef;
	my($oldnt)=undef;
	my($nt)=undef;
	my($nttype)=undef;
	
	my($mlength)=0;
	my($dupflag)=undef;
	
	my($postplace)=$_[1];
	while(defined($postplace) && length($postplace)>0) {
		my($lmlength)=undef;
		if($postplace =~ /^((?:INS)|(?:DEL)) ([ATCG]+)[ ,]+(?:NT)?([-+]?[0-9]+)/) {
			$lmlength=length($&);
			push(@numunittag,[undef,undef,$1]);
			$nt=$2;
			$nttype=$coords='NT';
			$fromplace=$3;
		} elsif($postplace =~ /^(-?[0-9]*)([ATCG]*) ((?:INS)|(?:DEL))/) {
			$lmlength=length($&);
			push(@numunittag,[undef,undef,$3]);
			if(length($1)>0) {
				$fromplace=$1;
				$coords='NT';
			}
			if(length($2)>0) {
				$nt=$2;
				$nttype='NT';
			}
		} elsif($postplace =~ /^((?:INS)|(?:DEL)) ([0-9]+) CODONS?/) {
			$lmlength=length($&);
			push(@numunittag,[$2,'CODON',$1]);
		} elsif($postplace =~ /^([A-Z]{3}) ((?:INS)|(?:INSERTION)|(?:DEL))/) {
			$lmlength=length($&);
			push(@numunittag,[undef,undef,(($2 eq 'INSERTION')?'INS':$2)]);
			$nt=$1;
			$nttype='AA';
		} elsif($postplace =~ /((?:INS)|(?:DEL))[ ,]+([0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?)-?((?:[KM]B)|(?:BP)|(?:EX)|(?:CODON))/) {
			$lmlength=length($&);
			my($numi,$uni,$ope)=($2,$3,$1);
			$numi=~s/,//;
			push(@numunittag,[$numi,$uni,$ope]);
		} elsif($postplace =~ /^([0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?)(?:-([0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?))?[- ]((?:[KM]B)|(?:BP)|(?:EX)|(?:CODON))[ ,]+((?:INS OR DEL)|(?:DEL\/INS)|(?:INS\/DEL)|(?:INS[-\/]DUP)|(?:INS)|(?:DEL)|(?:DUP))/) {
			$lmlength=length($&);
			my($numi,$uni,$ope)=($1.(defined($2)?('-'.$2):''),$3,$4);
			$numi=~s/,//;
			push(@numunittag,[$numi,$uni,$ope]);
		} elsif($mlength>0) {
			last;
		} else {
			unkMutation($_[0],$_[1]);
			return undef;
		}
		$mlength+=$lmlength;
		$postplace=substr($postplace,$lmlength);
		if($postplace=~/^[, \/]+(?:AND )?/) {
			$lmlength=length($&);
			$mlength+=$lmlength;
			$postplace=substr($postplace,$lmlength);
		}
	}
	
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<alterations>";
	
	foreach my $alt (@numunittag) {
		print $OUTPUT "<alteration type='$alt->[2]'",
			(defined($dupflag)?" subtype='DUP'":''),
			(defined($alt->[0])?" length='$alt->[0]'":''),
			(defined($alt->[1])?" unit='$alt->[1]'":''),
			" />";
	}
	
	until(undef) {
		if(defined($fromplace) || defined($nt)) {
			if(!defined($oldnt)) {
				foreach my $alt (@numunittag) {
					if($alt->[2] eq 'DEL') {
						$oldnt=$nt;
						$nt=undef;
						last;
					}
				}
			}
			printSubstitution($OUTPUT,[$nttype,$coords,$fromplace,$toplace,$oldnt,$nt]);
			($nttype,$coords,$fromplace,$toplace,$oldnt,$nt)=(undef,undef,undef,undef,undef,undef);
		}
		
		last  unless(defined($postplace) && length($postplace)>0);
		
		my($lmlength)=undef;
		if($postplace =~ /^[0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?(?:-[0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?)?[- ](?:(?:[KM]B)|(?:BP)|(?:EX)|(?:CODON))[ ,]+(?:(?:INS\/DEL)|(?:DEL\/INS)|(?:INS OR DEL)|(?:INS[-\/]DUP)|(?:INS)|(?:DEL)|(?:DUP))/) {
			$postplace=undef;
		} elsif($postplace =~ /^NT(-?[0-9]+)/) {
			$fromplace=$1;
			$coords='NT';
			$lmlength=length($&);
		} elsif($postplace =~ /^(-?[0-9]+)NT/) {
			$fromplace=$1;
			$coords='NT';
			$lmlength=length($&);
		} elsif($postplace =~ /^([-+][0-9]+) TO ([-+][0-9]+)/) {
			$fromplace=$1;
			$toplace=$2;
			$coords='NT/IVS';
			$lmlength=length($&);
		} elsif($postplace =~ /^[+-]?[0-9]+[, ]*[ATCG]+-[ATCG]+/ || $postplace =~ /^[ATCG-]+-?[0-9]+[ATCG]+/ || $postplace =~ /^[ATCG]+[-\/][ATCG]+/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^-?[0-9]+\+-?[0-9]+[ATCG]+-[ATCG]+/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^([ATGC]*)([-+]?[0-9]+)([ATGC]*)(?: (?:(?:INS)|(?:DEL)))?/) {
			$oldnt=$1  if(length($1)>0);
			$fromplace=$2;
			if(length($3)>0) {
				$nt=$3;
				$nttype='NT';
			}
			$coords='NT';
			$lmlength=length($&);
		} elsif($postplace =~ /^-?([ATCG]+), CODONS? ([0-9]+)\+?(?:(?:[-\/,]|(?: OR ))([0-9]+))?/) {
			$nt=$1;
			$nttype='NT';
			$fromplace=$2;
			$toplace=$3  if(defined($3) && length($3)>0);
			$coords='AA';
			$lmlength=length($&);
		} elsif($postplace =~ /^(DUP )?CODONS? ([0-9]+)\+?(?:(?:[-\/,]|(?: OR ))([0-9]+))?(?:, ([ATCG]+)(?:\/([ATCG]+))?)?/) {
			$dupflag=1  if(defined($1));
			$fromplace=$2;
			$toplace=$3  if(defined($3) && length($3)>0);
			if(defined($5) && length($5)>0) {
				$oldnt=$4;
				$nt=$5;
				$nttype='NT';
			} elsif(defined($4) && length($4)>0) {
				$nt=$4;
				$nttype='NT';
			}
			$coords='AA';
			$lmlength=length($&);
		} elsif($postplace =~ /^(?:(?:INS)|(?:DEL)) EXON [0-9]+/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^EX[0-9]+(?:-[0-9]+)? ?(?:(?:INS)|(?:DEL))?/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^EXON [0-9]+/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^([ATGC]+), EXON ([0-9]+)/) {
			$nt=$1;
			$nttype='NT';
			$fromplace=$2;
			$coords='EX';
			$lmlength=length($&);
		} elsif($postplace =~ /^IVS[0-9]+/ || $postplace =~ /^IVS(?:(?:AS)|(?:DS))?/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		#} elsif($postplace =~ /^IVS([0-9]+)(?:(?:INS)|(?:DEL))/) {
		#	$fromplace=$1;
		#	$coords='EX';
		#	$lmlength=length($&);
		} elsif($postplace =~ /^([A-Z]{3})([0-9]+)(?:(?:INS)|(?:DEL))/) {
			$nt=$1;
			$nttype='AA';
			$fromplace=$2  if(defined($2) && length($2)>0);
			$coords='AA';
			$lmlength=length($&);
		} elsif($postplace =~ /^[A-Z]{3}(?:(?:-?[0-9]+)|I)[A-Z]{3}/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^([A-Z]{3}(?:-[A-Z]{3})*) (?:(?:INS)|(?:DEL))(?:, CODONS? ([0-9]+)\+?(?:(?:[-\/,]|(?: OR ))([0-9]+))?)?/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^[A-Z]{3}[-?][A-Z]{3}/ || $postplace =~ /^TER-[A-Z]{3}/ || ($postplace =~ /^[A-Z]{3}-?[0-9]+/ && index($postplace,'IVS')!=0)) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} elsif($postplace =~ /^([ATGC]+)/) {
			$nt=$1;
			$nttype='NT';
			$lmlength=length($&);
		} elsif($postplace =~ /^[0-9]+[A-Z]+/) {
			my($neop)=processSubstitution($OUTPUT,$postplace);
			$lmlength=length($postplace)-(defined($neop)?length($neop):0);
		} else {
			$postplace=undef;
		}
		
		$mlength+=$lmlength  if(defined($lmlength));
		if(defined($postplace)) {
			$postplace=substr($postplace,$lmlength);
			if($postplace=~/^[, \/.]+(?:(?:(?:AND)|(?:OR)) )?/) {
				$lmlength=length($&);
				$mlength+=$lmlength;
				$postplace=substr($postplace,$lmlength);
			}
		}
	}
	
	print $OUTPUT "</alterations>";
	
	$postplace=substr($_[1],$mlength);
	$postplace =~ s/^[, .]+//;
	
	return $postplace;
}

sub unspecifiedAlteration($$) {
	my($alter)=undef;
	
	if($_[1] =~ /^(?:(?:INS)|(?:DEL)|(?:INS\/DEL)|(?:DUP))/) {
		$alter=$&;
	} else {
		unkMutation($_[0],$_[1]);
		return undef;
	}
	
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<alteration type='$alter' />";
	if($_[1] =~ /[, .]+(.+)$/) {
		return $1;
	}
	return undef;
}

sub processAndOr($$) {
	my($tag)=undef;
	
	if($_[1] =~ /^((?:AND)|(?:OR)) /) {
		$tag=$1;
	} else {
		unkMutation($_[0],$_[1]);
		return undef;
	}
	
	my($OUTPUT)=$_[0];
	
	print $OUTPUT "<",lc($tag)," />";
	
	if($_[1] =~ /^$tag[, .]+(.+)$/) {
		return $1;
	}
	
	return undef;
}

sub processMutation($\@$) {
	my($OUTPUT,$p_mutgene,$mutdesc)=@_;
	
	# All the traditional mutations
	print $OUTPUT "<geneSymbol>",join("</geneSymbol><geneSymbol>",@{$p_mutgene}),"</geneSymbol>";
	while(defined($mutdesc) && length($mutdesc)>0) {
		if($mutdesc =~ /^(?:(?:AND)|(?:OR)) /) {
			$mutdesc=processAndOr($OUTPUT,$mutdesc);
#		} elsif($mutdesc =~ /^EX[0-9]+(?:-[0-9]+)? ?(?:(?:INS)|(?:DEL)|(?:DUP))/) {
#		} elsif($mutdesc =~ /^EX[0-9]+(?:-[0-9]+)? ?(?:(?:INS)|(?:DEL)|(?:DUP))/) {
		} elsif($mutdesc =~ /^(?:(?:INS)|(?:DEL)) [ATCG]+[ ,]+(?:(?:NT[0-9]+)|(?:[-+][0-9]+))/) {
			$mutdesc=processInsDelDup($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^(?:(?:INS)|(?:DEL))[ ,]+[0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?-?(?:(?:[KM]B)|(?:BP)|(?:EX)|(?:CODON))/) {
			$mutdesc=processInsDelDup($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^[A-Z]{3}[ ,]+(?:(?:INS)|(?:INSERTION)|(?:DEL))/) {
			$mutdesc=processInsDelDup($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^-?[0-9]*[ATGC]* (?:(?:INS)|(?:DEL))/) {
			$mutdesc=processInsDelDup($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^[0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?(?:-[0-9]+(?:,[0-9]+)?(?:\.[0-9]+)?)?[- ](?:(?:[KM]B)|(?:BP)|(?:EX)|(?:CODON))[ ,]+(?:(?:INS\/DEL)|(?:DEL\/INS)|(?:INS OR DEL)|(?:INS[-\/]DUP)|(?:INS)|(?:DEL)|(?:DUP))/) {
			$mutdesc=processInsDelDup($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^(?:(?:INS)|(?:DEL)) EXON [0-9]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^EXON [0-9]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^INTRON [0-9]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^(?:(?:INS)|(?:DEL)) [0-9]+ CODON/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'DEL' || $mutdesc=~ /^DEL[ ,]/ || $mutdesc eq 'PARTIAL DEL' || $mutdesc=~ /^PARTIAL DEL[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'INS' || $mutdesc eq 'INS/DEL' || $mutdesc=~ /^INS(?:\/DEL)?[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'DUP' || $mutdesc=~ /^DUP[ ,]/ || $mutdesc eq 'DUPLICATION' || $mutdesc=~ /^DUPLICATION[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc=~ /^HAPLOTYPE/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'TRIPLICATION' || $mutdesc=~ /^TRIPLICATION[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'DEFICIENCY' || $mutdesc=~ /^DEFICIENCY[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'MULTIPLE CHANGES' || $mutdesc=~ /^MULTIPLE CHANGES[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'HYPERMETHYLATION' || $mutdesc=~ /^HYPERMETHYLATION[ ,]/ || $mutdesc eq 'PROMOTER HYPERMETHYLATION' || $mutdesc=~ /^PROMOTER HYPERMETHYLATION[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'EPIGENETICALLY SILENCED' || $mutdesc=~ /^EPIGENETICALLY SILENCED[ ,]/) {
			$mutdesc=unspecifiedAlteration($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^[-+]?[0-9]+[, ]*[ATCG]+-[ATCG]+/ || $mutdesc =~ /^[ATCG-]+-?[0-9]+[ATCG]+/ || $mutdesc =~ /^[ATCG]+[-\/][ATCG]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^NT-?[0-9]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^-?[0-9]+\+-?[0-9]+[ATCG]+-[ATCG]+/ || $mutdesc =~ /^[ATCG]+-[ATCG]+, (?:NT)?-?[0-9]+/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^IVS[0-9]+/ || $mutdesc =~ /^IVS(?:(?:AS)|(?:DS))?/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^EX[0-9]+ ?(?:(?:INS)|(?:DEL))?/) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^RS[0-9]+/) {
			$mutdesc=dbSNPVariant($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^[A-Z]{3}[0-9]+FS[0-9]+TER/) {
			unkMutation($OUTPUT,$mutdesc);
			#print $OUTPUT "<TODO3>$mutgene, $mutdesc</TODO3>";
			$mutdesc=undef;
		} elsif($mutdesc =~ /^[A-Z]{3}[-?][A-Z]{3}/ || $mutdesc =~ /^[A-Z]{3}(?:(?:-?[0-9]+)|I)[A-Z]{3}/ || $mutdesc =~ /^TER-[A-Z]{3}/ || $mutdesc =~ /^TER[0-9]+/ || $mutdesc =~ /^[0-9]+TER/ || ($mutdesc =~ /^[A-Z]{3}-?[0-9]+/ && index($mutdesc,'IVS')!=0)) {
			$mutdesc=processSubstitution($OUTPUT,$mutdesc);
		} elsif($mutdesc =~ /^FS-?[0-9]+TER/ || $mutdesc =~ /^FS, TER/) {
			$mutdesc=frameShiftGenTer($OUTPUT,$mutdesc);
		} elsif($mutdesc eq 'FS' || $mutdesc =~ /^FS[ ,]/) {
			$mutdesc=frameShift($OUTPUT,$mutdesc);
		} else {
			#unkMutation($OUTPUT,$mutdesc);
			print $OUTPUT "<TODO0>",join("/",@{$p_mutgene}),", $mutdesc</TODO0>";
			$mutdesc=undef;
		}
	}
}

sub printMutation($$$) {
	my($OUTPUT)=$_[0];
	my($mainGeneSymbol)=$_[1];
	my($mutation)=uc($_[2]);
	
	if(length($mutation)>0) {
		$mutation =~ s/[ \t]+$//;
		$mutation =~ s/^[ \t]+//;
		my($mutgene,$mutdesc)=split(/[;,]/,$mutation,2);
		
#		print STDERR $mutation,"\n"  if(index($mutation,',')==-1 && index($mutation,';')==-1);
#		print STDERR $mutation,' ',$mainGeneSymbol,"\n"  unless(!defined($mainGeneSymbol) || (defined($mutspl[1]) && $mutspl[0] eq $mainGeneSymbol));
#		print STDERR $mutspl[0],"\n"  if(scalar(@mutspl)==1);
		print $OUTPUT "\t\t\t<mutation raw='",XMLize($mutation),"'>";
		if(defined($mutdesc)) {
			$mutdesc =~ s/^[ \t]+//;
			
			my(@genelist)=split('/',$mutgene);
			processMutation($OUTPUT,@genelist,$mutdesc);
		} elsif(index($mutation,'FUSION')!=-1) {
			geneFusion($OUTPUT,substr($mutation,0,index($mutation,' ')));
		} elsif(index($mutation,'DEL')!=-1) {
			if(index($mutation,'PROMOTER')==0) {
				promoterDeletion($OUTPUT);
			} else {
				unspecificDeletion($OUTPUT,substr($mutation,0,index($mutation,' ')));
			}
		} elsif(index($mutation,' ')==-1) {
			if($mutation =~ /^[A-Z]{3}[0-9]+[A-Z]{3}$/) {
				my(@genelist)=($mainGeneSymbol);
				processMutation($OUTPUT,@genelist,$mutation);
			} else {
				unspecificMutation($OUTPUT,$mutation);
			}
		} else {
			unkMutation($OUTPUT,$mutation);
		}
		print $OUTPUT "</mutation>\n";
	}
}

sub printText($\@) {
	my($OUTPUT,$p_section)=@_;
	
	print $OUTPUT "\t\t<text>\n";
	my($sectlevel)=0;
	foreach my $sect (@{$p_section}) {
		if($sect->[0]>0) {
			if($sect->[0] >  $sectlevel) {
				while($sect->[0] > ($sectlevel+1)) {
					print $OUTPUT "\t\t\t<section name=''>\n";
					$sectlevel++;
				}
			} else {
				while($sectlevel >= $sect->[0]) {
					print $OUTPUT "\t\t\t</section>\n";
					$sectlevel--;
				}
			}
			$sectlevel=$sect->[0];
			print $OUTPUT "\t\t\t<section name='",XMLize($sect->[1]),"'>\n";
		}
		if(defined($sect->[2])) {
			print $OUTPUT "\t\t\t<para>",referenceTagger($sect->[2]),"</para>\n";
		}
	}
	# Closing the end
	while($sectlevel>0) {
		print $OUTPUT "\t\t\t</section>\n";
		$sectlevel--;
	}
	print $OUTPUT "\t\t</text>\n";
}
